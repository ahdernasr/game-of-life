import React, { useRef, useEffect } from "react";
import gridConfig from "./gridconfig";
import dragFunction from "./dragFunction";
import Sidebar from "./Sidebar";
const _ = require("lodash");

const Grid = () => {
  const grid = useRef() as React.MutableRefObject<HTMLInputElement>;

  // Localises dragFunction so it can be used in useEffect, otherwise throws error
  function enableDrag(): any {
    dragFunction(document.getElementById('grid'));
  }

  // 2D Array that will be defined later which allows easy access to nodes
  var nodesArray: any[] = [];
  let allNeighborsArray: HTMLElement[] = [];

  // Grid config has to contain width and height
  interface configCriteria {
    width: number;
    height: number;
  }

  // Marks selected not as enhabited
  function enhabitNode(node: HTMLElement) {
    node.classList.add("enhabited");
  }

  // Uses the created 2D Array of all the nodes to create a list of neighbors +
  // Uses x and y coordinates with top left as (0,0)
  function findNeighbors(node: any) {
    let neighborsList: any[] = [];

    if (node) {
      neighborsList = [
        nodesArray[node.data.x + 1][node.data.y],
        nodesArray[node.data.x + 1][node.data.y + 1],
        nodesArray[node.data.x + 1][node.data.y - 1],
        nodesArray[node.data.x - 1][node.data.y],
        nodesArray[node.data.x - 1][node.data.y + 1],
        nodesArray[node.data.x - 1][node.data.y - 1],
        nodesArray[node.data.x][node.data.y + 1],
        nodesArray[node.data.x][node.data.y - 1],
      ];
    }
    allNeighborsArray = allNeighborsArray.concat(neighborsList);

    return neighborsList;
  }

  // Auto plays generations
  function cycleGenerations() {
    setInterval(() => {
      nextGeneration();
    }, gridConfig.cycleSpeed);
  }

  // 
  function nextGeneration() {
    allNeighborsArray = [];

    const enhabitedArray: any[] = Array.from(
      document.querySelectorAll(".enhabited")
    );

    let toRemove: HTMLElement[] = [];
    let toAdd: HTMLElement[] = [];
    // what the problem is:
    // two for loops, first one is removing some neighbors which are required for the second loops, hence incorrect functionality
    for (let i = 0; i < enhabitedArray.length; i++) {
      // get a list of the neighbors of the enhabited node
      let neighborsList;

      neighborsList = findNeighbors(enhabitedArray[i]);

      let enhabitedNeighborsList = neighborsList.filter((neighbor) => {
        return neighbor && neighbor.classList.contains("enhabited");
      });

      if (
        enhabitedNeighborsList.length <= 1 ||
        enhabitedNeighborsList.length >= 4
      ) {
        toRemove.push(enhabitedArray[i]);
      }
    }

    for (let n of _.uniq(allNeighborsArray)) {
      let enhabitedNeighborsList = findNeighbors(n).filter((neighbor) => {
        return neighbor && neighbor.classList.contains("enhabited");
      });

      if (
        enhabitedNeighborsList.length === 3 &&
        !n.classList.contains("enhabited")
      ) {
        toAdd.push(n);
      }
    }

    toRemove.forEach((n) => {
      n.classList.remove("enhabited");
    });

    toAdd.forEach((n) => {
      n.classList.add("enhabited");
    });
  }

  useEffect(() => {
    
    enableDrag();

    function generateGrid(gridConfig: configCriteria) {
      const gridContainer = grid.current;

      // Grid generated by forming a row (div) element for the length
      for (let x: number = 0; x < gridConfig.width; x++) {
        let row = document.createElement("div");
        let rowArray: any = [];
        gridContainer.appendChild(row);

        // Fills row element with elements * height
        for (let y: number = 0; y < gridConfig.height; y++) {
          interface propertyCriteria {
            x: number;
            y: number;
          }
          let nodeProperties: propertyCriteria = {
            x: x,
            y: y,
          };

          let gridNode: any = document.createElement("div");
          gridNode.classList.add("grid-node");
          rowArray.push(gridNode);

          gridNode.data = nodeProperties;

          gridNode.onclick = () => {
            enhabitNode(gridNode);
          };

          row.appendChild(gridNode);
        }
        nodesArray.push(rowArray);
      }
    }

    generateGrid(gridConfig);

    // bring the middle element into view;
    nodesArray[gridConfig.width / 2][gridConfig.height / 2].scrollIntoView();

    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  return (
    <>
      <div id="grid" className="grid" ref={grid}></div>
      <Sidebar nextGeneration={nextGeneration} cycleGenerations={cycleGenerations}></Sidebar>
    </>
  );
};

export default Grid;
